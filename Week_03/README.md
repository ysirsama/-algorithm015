学习笔记

如何理解“递归” 递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。 递归需要满足的三个条件 同时满足以下三个条件，就可以用递归来解决

1. 一个问题的解可以分解为几个子问题的解 何为子问题？子问题就是数据规模更小的问题。比如，前面讲的电影院的例子，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样 电影院那个例子，你求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路，是一模一样的。
3. 存在递归终止条件 把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。 还是电影院的例子，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是 f(1)=1，这就是递归的终止条件。 如何编写递归代码？ 写递归代码最关键的是写出递推公式，找到终止条件，剩下将递推公式转化为代码就很简单了。 写递归代码的关键 • 找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码 • 只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤 递归重点技巧(自己的理解)
4. 重点是要将问题化成递归树，想清楚每一层的节点是怎么样的，只有思考清楚逻辑才能翻译成代码，并进行剪枝。 • 比如全排列的问题，可以选N个数值，相当于N叉树； • 但另外的角度，如果每个数字都是选或者不选，那就是2叉树
5. 要注意递归后的操作可能需要恢复现场，特别是使用全局的数据结构进行相关操作时
6. 在递归方法里面，重新调用递归几次，代表本层有几个兄弟节点 • 比如二叉树的遍历，通常是左右子树的遍历，所以会调用两次方法

递归C++模板 // C/C++ void recursion(int level, int param) { // recursion terminator if (level > MAX_LEVEL) { // process result return ; }

// process current logic process(level, param);

// drill down recursion(level + 1, param);

// reverse the current level status if needed } 要点

1. 不要人肉进行递归（最大误区）
2. 找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）
3. 数学归纳法思维 警惕堆栈溢出 可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。 警惕重复计算 不要谈递归色变，利用缓存避免重复计算，拥抱递归。可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。

------

分治 分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。 分治算法是一种处理问题的思想，递归是一种编程技巧 分治算法的递归实现中，每一层递归都会涉及这样三个操作： • 分解：将原问题分解成一系列子问题； • 解决：递归地求解各个子问题，若子问题足够小，则直接求解； • 合并：将子问题的结果合并成原问题。 分治算法能解决的问题，一般需要满足下面这几个条件： • 原问题与分解成的小问题具有相同的模式； • 原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别，等我们讲到动态规划的时候，会详细对比这两种算法； • 具有分解终止条件，也就是说，当问题足够小时，可以直接求解； • 可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。 代码模板 C/C++ int divide_conquer(Problem *problem, int params) { // recursion terminator if (problem == nullptr) { process_result return return_result; }

// process current problem subproblems = split_problem(problem, data) subresult1 = divide_conquer(subproblem[0], p1) subresult2 = divide_conquer(subproblem[1], p1) subresult3 = divide_conquer(subproblem[2], p1) ...

// merge result = process_result(subresult1, subresult2, subresult3) // revert the current level status

return 0; } result = process_result(res0, res1);

return result; }

------

回溯 如何理解“回溯算法”？ 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是狭义的指我们前面讲过的图的搜索算法，而是在一组可能的解中，搜索满足期望的解。 回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。 回溯要点 （1）注意终止条件后的“return”； （2）撤销就是为了让条件回归原始状态，相当于将一个使用后的材料重新复原然后再次使用，虽然在现实中这个很难出现，但是在程序中可以轻易实现，就如月光宝盒中回到过去一样。